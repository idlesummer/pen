import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import { duration } from '@idlesummer/tasker'
import { PACKAGE_NAME } from '@/core/constants'
import { buildComponentMap } from '@/core/route-builder'
import type { Task } from '@idlesummer/tasker'
import type { BuildContext } from '../types'

export const generateTasks: Task<BuildContext>[] = [
  {
    name: 'Writing manifest.ts',
    onSuccess: (_, dur) => `Saved manifest.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const manifestPath = join(genDir, 'manifest.ts')
      await mkdir(genDir, { recursive: true })

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        `import { RouteManifest } from '${PACKAGE_NAME}'`,
        '',
        `export const manifest: RouteManifest = ${JSON.stringify(ctx.manifest!, null, 2)} as const`,
        '',
      ].join('\n')

      await writeFile(manifestPath, code, 'utf-8')
    },
  },
  {
    name: 'Writing components.ts',
    onSuccess: (_, dur) => `Saved components.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const componentsPath = join(genDir, 'components.ts')
      await mkdir(genDir, { recursive: true })

      const componentMap = buildComponentMap(ctx.manifest!, ctx.outDir)
      const entries = Object.entries(componentMap).sort(([a], [b]) => a.localeCompare(b))

      const imports = entries
        .map(([_, importPath], i) => `import Component${i} from '${importPath}'`)
        .join('\n')

      const exports = entries
        .map(([absPath], i) => `  '${absPath.replace(/\\/g, '\\\\')}': Component${i},`)
        .join('\n')

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        `import type { ComponentMap } from '${PACKAGE_NAME}'`,
        '',
        imports,
        '',
        'export const components: ComponentMap = {',
        exports,
        '} as const',
        '',
      ].join('\n')

      await writeFile(componentsPath, code, 'utf-8')
    },
  },
  {
    name: 'Writing routes.tsx',
    onSuccess: (_, dur) => `Saved routes.tsx (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const routesPath = join(genDir, 'routes.tsx')
      await mkdir(genDir, { recursive: true })

      const componentMap = buildComponentMap(ctx.manifest!, ctx.outDir)
      const entries = Object.entries(componentMap).sort(([a], [b]) => a.localeCompare(b))

      // Generate component imports
      const imports = entries
        .map(([_, importPath], i) => `import Component${i} from '${importPath}'`)
        .join('\n')

      // Build component map for composition
      const componentMapCode = entries
        .map(([absPath], i) => `  '${absPath.replace(/\\/g, '\\\\')}': Component${i},`)
        .join('\n')

      // Generate pre-built route elements
      const routeElements: string[] = []
      for (const [url, route] of Object.entries(ctx.manifest!)) {
        const elementCode = generateRouteElement(route, entries)
        routeElements.push(`  '${url}': ${elementCode},`)
      }

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        "import { createElement } from 'react'",
        `import { ErrorBoundary, NotFoundBoundary, type PrebuiltRoutes } from '${PACKAGE_NAME}'`,
        '',
        imports,
        '',
        '// Pre-built route elements composed at build time',
        'export const routes: PrebuiltRoutes = {',
        routeElements.join('\n'),
        '} as const',
        '',
      ].join('\n')

      await writeFile(routesPath, code, 'utf-8')
    },
  },
  {
    name: 'Writing entry.ts',
    onSuccess: (_, dur) => `Saved entry.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const entryPath = join(genDir, 'entry.ts')
      await mkdir(genDir, { recursive: true })

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        'import { createElement } from \'react\'',
        'import { render } from \'ink\'',
        `import { App } from '${PACKAGE_NAME}'`,
        '',
        'import { routes } from \'./routes\'',
        '',
        'export async function run(initialUrl: string) {',
        '  const element = createElement(App, { initialUrl, routes })',
        '  const { waitUntilExit } = render(element)',
        '  await waitUntilExit()',
        '}',
        '',
      ].join('\n')

      await writeFile(entryPath, code, 'utf-8')
    },
  },
]

/**
 * Generates the code for a single route element tree.
 * Mirrors the runtime composition logic from composer.ts but generates static code.
 */
function generateRouteElement(
  route: { url: string; chain: Array<Record<string, string>> },
  componentEntries: Array<[string, string]>,
): string {
  const getComponentIndex = (path: string) => {
    const index = componentEntries.findIndex(([absPath]) => absPath === path)
    if (index === -1) throw new Error(`Component not found: ${path}`)
    return index
  }

  // Start with the screen from the first segment
  const leafSegment = route.chain[0]!
  const screenPath = leafSegment['screen']!
  const screenIndex = getComponentIndex(screenPath)
  let element = `createElement(Component${screenIndex}, { key: '${screenPath}' })`

  // Process segments from leaf â†’ root (same order as composer.ts)
  for (const segment of route.chain) {
    // Not-found boundary
    if (segment['not-found']) {
      const path = segment['not-found']
      const index = getComponentIndex(path)
      element = `createElement(NotFoundBoundary, { key: '${path}', fallback: Component${index} }, ${element})`
    }

    // Error boundary
    if (segment['error']) {
      const path = segment['error']
      const index = getComponentIndex(path)
      element = `createElement(ErrorBoundary, { key: '${path}', fallback: Component${index} }, ${element})`
    }

    // Layout
    if (segment['layout']) {
      const path = segment['layout']
      const index = getComponentIndex(path)
      element = `createElement(Component${index}, { key: '${path}' }, ${element})`
    }
  }

  return element
}
