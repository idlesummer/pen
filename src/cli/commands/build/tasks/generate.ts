import type { Task } from '@idlesummer/tasker'
import type { BuildContext } from '../types'
import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import { duration } from '@idlesummer/tasker'
import { PACKAGE_NAME } from '@/core/constants'
import { generateRouteElement } from '../codegen/composer'

export const generateTasks: Task<BuildContext>[] = [
  {
    name: 'Writing manifest.ts',
    onSuccess: (_, dur) => `Saved manifest.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const manifestPath = join(genDir, 'manifest.ts')
      await mkdir(genDir, { recursive: true })

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '// NOTE: This file is kept for documentation/debugging.',
        '// Runtime uses pre-built routes from routes.ts instead.',
        '',
        `import { RouteManifest } from '${PACKAGE_NAME}'`,
        '',
        `export const manifest: RouteManifest = ${JSON.stringify(ctx.manifest!, null, 2)} as const`,
        '',
      ].join('\n')

      await writeFile(manifestPath, code, 'utf-8')
    },
  },
  {
    name: 'Writing routes.ts',
    onSuccess: (_, dur) => `Saved routes.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const routesPath = join(genDir, 'routes.ts')
      await mkdir(genDir, { recursive: true })

      const entries = ctx.componentEntries!

      // Generate component imports
      const imports = entries
        .map((e, i) => `import Component${i} from '${e.importPath}'`)
        .join('\n')

      // Generate path lookup table to deduplicate absolute paths
      const importPaths = entries
        .map(e => `  ${JSON.stringify(e.absolutePath)},`)
        .join('\n')

      // Build path-to-index lookup for route element generation
      const pathToIndex = Object.fromEntries(
        entries.map((e, i) => [e.absolutePath, i])
      )

      // Generate pre-built route elements
      const routeElements: string[] = []
      for (const [url, route] of Object.entries(ctx.manifest!)) {
        const elementCode = generateRouteElement(route, pathToIndex)
        routeElements.push(`  '${url}': ${elementCode},`)
      }

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        `import type { CompiledRoutes } from '${PACKAGE_NAME}'`,
        "import { createElement } from 'react'",
        '',
        imports,
        '',
        '// Path lookup table (deduplicates absolute paths used as keys)',
        'const importPaths = [',
        importPaths,
        '] as const',
        '',
        '// Compiled route elements generated at build time',
        'export const routes: CompiledRoutes = {',
        routeElements.join('\n'),
        '} as const',
        '',
      ].join('\n')

      await writeFile(routesPath, code, 'utf-8')
    },
  },
  {
    name: 'Writing entry.ts',
    onSuccess: (_, dur) => `Saved entry.ts (${duration(dur)})`,
    run: async (ctx) => {
      const genDir = join(ctx.outDir, 'generated')
      const entryPath = join(genDir, 'entry.ts')
      await mkdir(genDir, { recursive: true })

      const code = [
        `// Auto-generated by ${PACKAGE_NAME}`,
        '// Do not manually edit this file',
        '',
        'import { createElement } from \'react\'',
        'import { render } from \'ink\'',
        `import { App } from '${PACKAGE_NAME}'`,
        'import { routes } from \'./routes\'',
        '',
        'export async function run(initialUrl: string) {',
        '  const element = createElement(App, { initialUrl, routes })',
        '  const { waitUntilExit } = render(element)',
        '  await waitUntilExit()',
        '}',
        '',
      ].join('\n')

      await writeFile(entryPath, code, 'utf-8')
    },
  },
]
