import type { Task } from '@idlesummer/tasker'
import type { BuildContext } from '../types'
import type { Route } from '@/core/route-builder'
import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import { duration } from '@idlesummer/tasker'
import { PACKAGE_NAME } from '@/core/constants'

// ===== Main Task =====

export const writeRoutesFile: Task<BuildContext> = {
  name: 'Writing routes.ts',
  onSuccess: (_, dur) => `Saved routes.ts (${duration(dur)})`,
  run: async (ctx) => {
    const genDir = join(ctx.outDir, 'generated')
    const routesPath = join(genDir, 'routes.ts')
    await mkdir(genDir, { recursive: true })

    const entries = ctx.componentEntries!

    // Generate component imports
    const imports = entries
      .map((e, i) => `import Component${i} from '${e.importPath}'`)
      .join('\n')

    // Generate path lookup table to deduplicate absolute paths
    const importPaths = entries
      .map(e => `  ${JSON.stringify(e.absolutePath)},`)
      .join('\n')

    // Build path-to-index lookup for route element generation
    const pathToIndex = Object.fromEntries(entries.map((e, i) => [e.absolutePath, i]))

    // Generate pre-built route elements
    const routeElements: string[] = []
    for (const [url, route] of Object.entries(ctx.manifest!)) {
      const elementCode = generateRouteElement(route, pathToIndex)
      routeElements.push(`  '${url}': ${elementCode},`)
    }

    const code = [
      `// Auto-generated by ${PACKAGE_NAME}`,
      '// Do not manually edit this file',
      '',
      `import type { CompiledRoutes } from '${PACKAGE_NAME}'`,
      'import { createElement } from \'react\'',
      '',
      imports,
      '',
      '// Use import paths as unique keys',
      'const importPaths = [',
      importPaths,
      '] as const',
      '',
      '// Compiled route elements generated at build time',
      'export const routes: CompiledRoutes = {',
      routeElements.join('\n'),
      '} as const',
      '',
    ].join('\n')

    await writeFile(routesPath, code, 'utf-8')
  },
}

// ===== Helpers =====

/**
 * Generates a route element by composing React components into nested createElement calls.
 *
 * This function mirrors the runtime composition logic but generates static code strings
 * that will be written to the generated routes.ts file.
 *
 * Composition order per segment (inside to outside):
 * 1. Screen component (only in leaf segment)
 * 2. Not-found boundary (wraps screen if present)
 * 3. Layout (wraps content)
 * 4. Error boundary (wraps layout + all descendants)
 */
function generateRouteElement(route: Route, pathToIndex: Record<string, number>) {
  const getComponentIndex = (path: string) => {
    const index = pathToIndex[path]
    if (index === undefined) throw new Error(`Component not found: ${path}`)
    return index
  }

  // Start with the screen from the first segment
  const leafSegment = route.chain[0]!
  const screenPath = leafSegment['screen']!
  const screenIndex = getComponentIndex(screenPath)
  let element = `createElement(Component${screenIndex}, { key: importPaths[${screenIndex}] })`

  // Process segments from leaf â†’ root (same order as runtime composition)
  for (const segment of route.chain) {
    // Not-found boundary
    if (segment['not-found']) {
      const path = segment['not-found']
      const index = getComponentIndex(path)
      element = `createElement(NotFoundBoundary, { key: importPaths[${index}], fallback: Component${index} }, ${element})`
    }

    // Error boundary
    if (segment['error']) {
      const path = segment['error']
      const index = getComponentIndex(path)
      element = `createElement(ErrorBoundary, { key: importPaths[${index}], fallback: Component${index} }, ${element})`
    }

    // Layout
    if (segment['layout']) {
      const path = segment['layout']
      const index = getComponentIndex(path)
      element = `createElement(Component${index}, { key: importPaths[${index}] }, ${element})`
    }
  }

  return element
}
