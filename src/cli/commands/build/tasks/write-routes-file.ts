import type { Task } from '@idlesummer/tasker'
import type { ComponentImportData, Route } from '@/core/route-builder'
import type { BuildContext } from '../types'
import { mkdir, writeFile } from 'fs/promises'
import { join } from 'path'
import { duration } from '@idlesummer/tasker'
import { PACKAGE_NAME } from '@/core/constants'

export const writeRoutesFile: Task<BuildContext> = {
  name: 'Writing routes.ts',
  onSuccess: (_, dur) => `Saved routes.ts (${duration(dur)})`,
  run: async (ctx) => {
    const genDir = join(ctx.outDir, 'generated')
    const routesPath = join(genDir, 'routes.ts')
    const componentImports = ctx.componentImports!

    // Generate component imports
    const importStatements = componentImports.imports
      .map((importPath, i) => `import Component${i} from '${importPath}'`)
      .join('\n')

    // Generate pre-built route elements
    const routeElements: string[] = []
    for (const [url, route] of Object.entries(ctx.manifest!)) {
      const elementCode = buildRouteElement(route, componentImports)
      const formatted = '\n    ' + formatCode(elementCode).replace(/\n/g, '\n    ')
      routeElements.push(`  '${url}': ${formatted},`)
    }

    const code = [
      `// Auto-generated by ${PACKAGE_NAME}`,
      '// Do not manually edit this file',
      '',
      `import type { CompiledRoutes } from '${PACKAGE_NAME}'`,
      'import { createElement } from \'react\'',
      '',
      importStatements,
      '',
      '// Compiled route elements generated at build time',
      'export const routes: CompiledRoutes = {',
      routeElements.join('\n'),
      '} as const',
      '',
    ].join('\n')

    await mkdir(genDir, { recursive: true })
    await writeFile(routesPath, code, 'utf-8')
  },
}

/**
 * Builds a route element by composing React components into nested createElement calls.
 *
 * This function mirrors the runtime composition logic but generates static code strings
 * that will be written to the generated routes.ts file.
 *
 * Composition order per segment (inside to outside):
 * 1. Screen component (only in leaf segment)
 * 2. Not-found boundary (wraps screen if present)
 * 3. Layout (wraps content)
 * 4. Error boundary (wraps layout + all descendants)
 */
function buildRouteElement(route: Route, { indices, imports }: ComponentImportData) {
  const generateElement = (name: string, path: string, extraProps = '', child = '') => {
    const index = indices[path]!
    const props = `{ key: '${imports[index]}'${extraProps} }`
    return `createElement(${name}, ${props}${child ? `, ${child}` : ''})`
  }

  const segment = route.chain[0]!
  let element = generateElement(`Component${indices[segment['screen']!]!}`, segment['screen']!)

  for (const segment of route.chain) {
    if (segment['not-found']) {
      const index = indices[segment['not-found']]!
      element = generateElement('NotFoundBoundary', segment['not-found'], `, fallback: Component${index}`, element)
    }
    if (segment['error']) {
      const index = indices[segment['error']]!
      element = generateElement('ErrorBoundary', segment['error'], `, fallback: Component${index}`, element)
    }
    if (segment['layout']) {
      const index = indices[segment['layout']]!
      element = generateElement(`Component${index}`, segment['layout'], '', element)
    }
  }
  return element
}

/**
 * Formats generated code for readability.
 * Adds line breaks and indentation to nested createElement chains.
 */
function formatCode(code: string): string {
  let depth = 0
  let result = ''
  const argCounts = [0]

  for (let i = 0; i < code.length; i++) {
    const char = code[i]
    const prevChar = code[i - 1]

    if (char === '(' && prevChar && /[a-zA-Z0-9]/.test(prevChar)) {
      argCounts[++depth] = 0
      result += '('
    }
    else if (char === ')') {
      const multiLine = argCounts[depth]! >= 2
      result += multiLine ? `\n${'  '.repeat(--depth)})` : ')'
      if (!multiLine) depth--
      argCounts.pop()
    }
    else if (char === ',' && code[i + 1] === ' ') {
      const argCount = ++argCounts[depth]!
      result += argCount >= 2 ? `,\n${'  '.repeat(depth)}` : ', '
      i++ // Skip space
    }
    else
      result += char
  }
  return result
}
